<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Details</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <style>
        html, body {
            height: 100%;
        }

        body {
            background: #141618;
            margin: 0;
            color: #fff;
            font-family: 'Roboto Condensed',sans-serif;
        }

        .spell-window {
            display: grid;
            grid-template-rows: auto 1fr auto;
            min-height: 100%;
            max-width: 100vw;
        }

        .popup-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
            background: linear-gradient(180deg,rgba(255,255,255,0.05),rgba(255,255,255,0));
        }

            .popup-header h3 {
                margin: 0;
                font-size: 16px;
                font-weight: 700;
            }

        .popup-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .seg {
            display: flex;
            background: rgba(255,255,255,0.08);
            border-radius: 8px;
        }

        .seg-btn {
            border: 0;
            padding: 4px 10px;
            color: #fff;
            background: transparent;
            cursor: pointer;
            font: inherit;
            height: 28px;
            line-height: 28px;
        }

            .seg-btn.active {
                background: rgba(255,255,255,0.16);
                border-radius: 8px;
            }

        .close-btn {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            font-size: 13px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
        }

            .close-btn:hover {
                background: rgba(255,255,255,0.12);
            }

        #spellSearch {
            height: 28px;
            padding: 0 8px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.15);
            background: rgba(0,0,0,0.25);
            color: #fff;
            outline: none;
            width: 220px;
        }

        .popup-body {
            /* on évite le scroll imbriqué */
            overflow: clip; /* ou hidden si tu préfères */
            padding: 8px 12px;
        }

        .spell-summary {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
        }

        .spell-chip {
            padding: 4px 8px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 999px;
            font-size: 11px;
        }

        .table-wrap {
            overflow: auto;
            border-radius: 8px;
            /* ces deux lignes éliminent le clignotement */
            scrollbar-gutter: stable both-edges;
            overscroll-behavior: contain;
        }

        .spell-table {
            font-variant-numeric: tabular-nums lining-nums;
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 12px;
        }

            .spell-table thead[role="rowgroup"] th[scope="col"]:not(:first-child) {
                position: sticky;
                top: 0;
                background: rgba(0,0,0,0.35);
                text-align: right;
                padding: 6px 8px;
                font-weight: 700;
                cursor: pointer;
                border-bottom: 1px solid rgba(255,255,255,0.08);
            }

            .spell-table thead.stuck {
                box-shadow: 0 2px 0 rgba(255,255,255,0.08);
            }

            .spell-table tbody td {
                padding: 6px 8px;
                border-bottom: 1px solid rgba(255,255,255,0.06);
                vertical-align: middle;
            }

            .spell-table tbody tr:nth-child(odd) {
                background: rgba(255,255,255,0.025);
            }

            .spell-table tbody tr:hover {
                background: rgba(255,255,255,0.06);
            }

            .spell-table tfoot td {
                padding: 8px;
                border-top: 1px solid rgba(255,255,255,0.1);
                font-weight: 700;
                background: rgba(255,255,255,0.04);
            }

        .col-num, .col-share {
            width: 110px;
            text-align: right;
            white-space: nowrap;
        }

        .col-casts {
            width: 90px;
            text-align: right;
            white-space: nowrap;
        }

        .spell-row-name {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 260px;
        }

        .badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 6px;
            background: rgba(255,255,255,.12);
        }

            .badge.dmg {
                background: #3b1a1a;
                color: #ff9c9e;
            }

            .badge.heal {
                background: #17361c;
                color: #8de39b;
            }

            .badge.mix {
                background: #262b3a;
                color: #a9c7ff;
            }

        .spell-icon {
            width: 18px;
            height: 18px;
            border-radius: 3px;
            object-fit: cover;
            flex-shrink: 0;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.4) inset;
        }

        .spell-name {
            font-weight: 600;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .dual-bars {
            margin-top: 4px;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .bar {
            height: 8px;
            border-radius: 999px;
            background: rgba(255,255,255,0.08);
            overflow: hidden;
        }

            .bar .fill {
                display: block;
                height: 100%;
                width: 0%;
                transition: width .35s ease;
            }

            .bar.damage .fill {
                background: linear-gradient(90deg,#ff4d4f,#c62828);
            }
            /* rouge */
            .bar.heal .fill {
                background: linear-gradient(90deg,#4caf50,#2e7d32);
            }
        /* vert  */

        .popup-footer {
            padding: 8px 12px;
            border-top: 1px solid rgba(255,255,255,0.08);
            color: #cfcfcf;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
        }

        .th-sort-asc::after {
            content: "▲";
            margin-left: 6px;
            font-size: 10px;
            opacity: .8;
        }

        .th-sort-desc::after {
            content: "▼";
            margin-left: 6px;
            font-size: 10px;
            opacity: .8;
        }
    </style>
</head>
<body>
    <div class="spell-window" id="windowRoot">
        <div class="popup-header">
            <h3 id="popupTitle">Spells</h3>
            <div class="popup-actions">
                <!-- Filtre rapide -->
                <div class="seg" aria-label="Filter">
                    <button class="seg-btn active" data-mode="all" title="Show all">All</button>
                    <button class="seg-btn" data-mode="dmg" title="Show damage only">Damage</button>
                    <button class="seg-btn" data-mode="heal" title="Show healing only">Heal</button>
                </div>
                <input id="spellSearch" type="search" placeholder="Filter a spell... (press / to focus)">
                <button class="close-btn" onclick="window.close()">Close</button>
            </div>
        </div>

        <div class="popup-body">
            <div id="spellSummary" class="spell-summary"></div>
            <div class="table-wrap">
                <table class="spell-table" id="spellTable" aria-label="Spells details">
                    <thead role="rowgroup" id="tableHead">
                        <tr>
                            <th scope="col" data-sort="name">Spell</th>
                            <th scope="col" class="col-num" data-sort="damage">Damage</th>
                            <th scope="col" class="col-num" data-sort="heal">Heal</th>
                            <th scope="col" class="col-casts" data-sort="casts">Casts</th>
                            <th scope="col" class="col-share" data-sort="shareDmg">% Dmg</th>
                            <th scope="col" class="col-share" data-sort="shareHeal">% Heal</th>
                        </tr>
                    </thead>
                    <tbody id="spellTbody" role="rowgroup"></tbody>
                    <tfoot role="rowgroup">
                        <tr>
                            <td>Total</td>
                            <td id="sumDmg" class="col-num" title="0">0</td>
                            <td id="sumHeal" class="col-num" title="0">0</td>
                            <td id="sumCasts" class="col-casts" title="0">0</td>
                            <td class="col-share">100%</td>
                            <td class="col-share">100%</td>
                        </tr>
                    </tfoot>
                </table>
            </div>
        </div>

        <div class="popup-footer">
            <span id="spellFooter">—</span>
        </div>
    </div>

    <script>
        let DATA = null;
        let sortKey = "shareDmg";
        let sortDir = "desc";
        let sortingBound = false;
        let lastRenderKey = "";
        let sizedOnce = false;
        let modeFilter = "all"; // 'all' | 'dmg' | 'heal'

        const $ = (s) => document.querySelector(s);
        const tbody = $("#spellTbody");
        const thead = $("#spellTable thead");
        const summary = $("#spellSummary");
        const footer = $("#spellFooter");
        const search = $("#spellSearch");
        const tableWrap = document.querySelector(".table-wrap");
        const sumDmg = $("#sumDmg"), sumHeal = $("#sumHeal"), sumCasts = $("#sumCasts");

        const HEAL_OFFSET = 1_000_000_000;
        const PREF_KEY = "details_prefs";

        function formatNumber(n) {
            if (isNaN(n)) return "NaN";
            if (n >= 1e6) return (n / 1e6).toFixed(1) + "M";
            if (n >= 1e3) return (n / 1e3).toFixed(1) + "K";
            return Math.round(n).toString();
        }
        function setNumCellText(cell, value) {
            cell.textContent = formatNumber(value);
            cell.title = String(value);
        }

        function renderHeader() {
            thead.querySelectorAll("th").forEach(th => th.classList.remove("th-sort-asc", "th-sort-desc"));
            const th = thead.querySelector(`th[data-sort="${sortKey}"]`);
            if (th) th.classList.add(sortDir === "asc" ? "th-sort-asc" : "th-sort-desc");
        }

        // Agrégation + tag kind
        function aggregateItems(items) {
            const byBase = new Map();
            for (const it of items) {
                const baseId = Number(it.id) % HEAL_OFFSET;
                const key = String(baseId);
                const entry = byBase.get(key) || { id: key, name: it.name, damage: 0, heal: 0, casts: 0, dmgCasts: 0, healCasts: 0, kind: "dmg" };

                if (!entry.name || (it.name && String(it.name).length > String(entry.name).length)) entry.name = it.name;

                const type = (it.type || "").toLowerCase();
                const amount = it.damage || it.totalDamage || 0;
                const count = Number(
                    it.casts ?? it.totalCount ?? (it.countBreakdown && typeof it.countBreakdown.total === "number" ? it.countBreakdown.total : undefined) ?? it.hits ?? 0
                ) || 0;

                if (type === "healing" || Number(it.id) >= HEAL_OFFSET) {
                    entry.heal += amount; entry.healCasts += count;
                } else {
                    entry.damage += amount; entry.dmgCasts += count;
                }
                entry.casts = entry.dmgCasts + entry.healCasts;
                entry.kind = (entry.damage && entry.heal) ? "mix" : (entry.heal ? "heal" : "dmg");

                byBase.set(key, entry);
            }
            return Array.from(byBase.values());
        }

        function getTotals(rows) {
            const totalDamage = rows.reduce((s, r) => s + (r.damage || 0), 0);
            const totalHeal = rows.reduce((s, r) => s + (r.heal || 0), 0);
            const totalCasts = rows.reduce((s, r) => s + (r.casts || 0), 0);
            return { totalDamage, totalHeal, totalCasts };
        }

        function getSortedFilteredData(rows, totals) {
            const filter = search.value.toLowerCase();
            const data = rows
                .filter(r => r.name.toLowerCase().includes(filter))
                .filter(r => modeFilter === 'all' ? true : (modeFilter === 'dmg' ? r.damage > 0 : r.heal > 0))
                .map(r => ({
                    ...r,
                    shareDmg: totals.totalDamage > 0 ? (r.damage / totals.totalDamage) * 100 : 0,
                    shareHeal: totals.totalHeal > 0 ? (r.heal / totals.totalHeal) * 100 : 0
                }));

            const dir = sortDir === "asc" ? 1 : -1;
            data.sort((a, b) => {
                if (sortKey === "name") return a.name.localeCompare(b.name, "en", { sensitivity: "base" }) * dir;
                return (((a[sortKey] ?? 0) - (b[sortKey] ?? 0)) * dir);
            });
            return data;
        }

        function rebuildTable() {
            const { items } = DATA;
            const rows = aggregateItems(items);
            const totals = getTotals(rows);
            const data = getSortedFilteredData(rows, totals);

            const maxDmg = Math.max(0, ...data.map(r => r.damage || 0));
            const maxHeal = Math.max(0, ...data.map(r => r.heal || 0));

            tbody.innerHTML = "";
            const frag = document.createDocumentFragment();

            for (const r of data) {
                const tr = document.createElement("tr");
                tr.dataset.id = r.id;

                const tdName = document.createElement("td");
                const rowName = document.createElement("div"); rowName.className = "spell-row-name";

                const badge = document.createElement("span");
                badge.className = `badge ${r.kind}`; badge.textContent = r.kind.toUpperCase();

                const icon = document.createElement("img");
                icon.className = "spell-icon"; icon.src = `assets/skills/${r.id}.webp`; icon.addEventListener("error", () => icon.remove());

                const nameEl = document.createElement("div");
                nameEl.className = "spell-name"; nameEl.textContent = r.name;

                const bars = document.createElement("div"); bars.className = "dual-bars";

                const barD = document.createElement("div"); barD.className = "bar damage";
                const fillD = document.createElement("span"); fillD.className = "fill";
                const wD = maxDmg > 0 ? ((r.damage / maxDmg) * 100).toFixed(3) + "%" : "0%";
                fillD.style.width = wD; fillD.title = `Damage: ${r.damage}`;
                barD.appendChild(fillD);

                const barH = document.createElement("div"); barH.className = "bar heal";
                const fillH = document.createElement("span"); fillH.className = "fill";
                const wH = maxHeal > 0 ? ((r.heal / maxHeal) * 100).toFixed(3) + "%" : "0%";
                fillH.style.width = wH; fillH.title = `Heal: ${r.heal}`;
                barH.appendChild(fillH);

                bars.append(barD, barH);
                rowName.append(badge, icon, nameEl);
                tdName.append(rowName, bars);

                const tdDmg = document.createElement("td"); tdDmg.className = "col-num"; setNumCellText(tdDmg, r.damage);
                const tdHeal = document.createElement("td"); tdHeal.className = "col-num"; setNumCellText(tdHeal, r.heal);
                const tdCasts = document.createElement("td"); tdCasts.className = "col-casts"; setNumCellText(tdCasts, r.casts);

                const tdShareD = document.createElement("td"); tdShareD.className = "col-share";
                setNumCellText(tdShareD, Number(((totals.totalDamage > 0 ? (r.damage / totals.totalDamage * 100) : 0).toFixed(1))));
                tdShareD.textContent = `${tdShareD.textContent}%`;

                const tdShareH = document.createElement("td"); tdShareH.className = "col-share";
                setNumCellText(tdShareH, Number(((totals.totalHeal > 0 ? (r.heal / totals.totalHeal * 100) : 0).toFixed(1))));
                tdShareH.textContent = `${tdShareH.textContent}%`;

                tr.append(tdName, tdDmg, tdHeal, tdCasts, tdShareD, tdShareH);
                frag.appendChild(tr);
            }
            tbody.appendChild(frag);

            // Maj tfoot
            setNumCellText(sumDmg, totals.totalDamage);
            setNumCellText(sumHeal, totals.totalHeal);
            setNumCellText(sumCasts, totals.totalCasts);

            renderSummary(totals);
            setInitialSizeOnce();
        }

        function updateValuesOnly() {
            const { items } = DATA;
            const rows = aggregateItems(items);
            const totals = getTotals(rows);
            const data = getSortedFilteredData(rows, totals);

            const currentRows = Array.from(tbody.children);
            const currentIds = new Set(currentRows.map(r => r.dataset.id));
            const newIds = new Set(data.map(d => String(d.id)));
            if (currentRows.length !== data.length || ![...currentIds].every(id => newIds.has(id))) {
                rebuildTable(); return;
            }

            const maxDmg = Math.max(0, ...data.map(r => r.damage || 0));
            const maxHeal = Math.max(0, ...data.map(r => r.heal || 0));

            tbody.querySelectorAll(".fill").forEach(f => f.style.transition = "none");

            for (const r of data) {
                const tr = tbody.querySelector(`tr[data-id="${r.id}"]`); if (!tr) continue;

                const nums = tr.querySelectorAll(".col-num");
                if (nums[0]) setNumCellText(nums[0], r.damage);
                if (nums[1]) setNumCellText(nums[1], r.heal);

                const castsCell = tr.querySelector(".col-casts");
                if (castsCell) setNumCellText(castsCell, r.casts);

                const shares = tr.querySelectorAll(".col-share");
                if (shares[0]) {
                    const v = totals.totalDamage > 0 ? (r.damage / totals.totalDamage * 100) : 0;
                    shares[0].textContent = `${v.toFixed(1)}%`; shares[0].title = v.toString();
                }
                if (shares[1]) {
                    const v = totals.totalHeal > 0 ? (r.heal / totals.totalHeal * 100) : 0;
                    shares[1].textContent = `${v.toFixed(1)}%`; shares[1].title = v.toString();
                }

                const fills = tr.querySelectorAll(".fill");
                if (fills[0]) {
                    const w = maxDmg > 0 ? ((r.damage / maxDmg) * 100).toFixed(3) + "%" : "0%";
                    fills[0].style.width = w; fills[0].title = `Damage: ${r.damage}`;
                }
                if (fills[1]) {
                    const w = maxHeal > 0 ? ((r.heal / maxHeal) * 100).toFixed(3) + "%" : "0%";
                    fills[1].style.width = w; fills[1].title = `Heal: ${r.heal}`;
                }
            }
            setTimeout(() => tbody.querySelectorAll(".fill").forEach(f => f.style.transition = "width .35s ease"), 50);

            // Maj tfoot
            setNumCellText(sumDmg, totals.totalDamage);
            setNumCellText(sumHeal, totals.totalHeal);
            setNumCellText(sumCasts, totals.totalCasts);

            renderSummary(totals);
        }

        function renderSummary(totals) {
            const { user } = DATA;
            summary.replaceChildren();
            const chips = [
                { label: "Class", value: user.profession },
                { label: "DPS", value: formatNumber(user.realtime_dps) },
                { label: "Max DPS", value: formatNumber(user.realtime_dps_max) },
                { label: "HPS", value: formatNumber(user.realtime_hps) },
                { label: "Max HPS", value: formatNumber(user.realtime_hps_max) },
                { label: "Total Damage", value: formatNumber(totals.totalDamage) },
                { label: "Total Healing", value: formatNumber(totals.totalHeal) },
                { label: "Hits", value: user.total_count.total },
                { label: "FP", value: user.fightPoint },
                { label: "Max HP", value: user.max_hp },
                { label: "Deaths", value: user.dead_count }
            ];
            for (const c of chips) {
                const span = document.createElement("span");
                span.className = "spell-chip";
                span.textContent = `${c.label}: ${c.value}`;
                summary.appendChild(span);
            }
            $("#popupTitle").textContent = `${user.name}`;
            footer.textContent = `Total: ${formatNumber(totals.totalDamage)} dmg • ${formatNumber(totals.totalHeal)} heal • ${tbody.children.length} skills`;
        }

        function bindSortingOnce() {
            if (sortingBound) return;
            sortingBound = true;
            thead.querySelectorAll("th[data-sort]").forEach(th => {
                th.addEventListener("click", () => {
                    const key = th.getAttribute("data-sort");
                    if (key === sortKey) sortDir = (sortDir === "asc") ? "desc" : "asc";
                    else { sortKey = key; sortDir = "desc"; }
                    savePrefs();
                    renderHeader(); rebuildTable();
                });
            });
            // Ombre sticky header
            tableWrap.addEventListener("scroll", () => {
                thead.classList.toggle("stuck", tableWrap.scrollTop > 0);
            });
            // Filtre segmenté
            document.querySelectorAll('.seg-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.seg-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    modeFilter = btn.dataset.mode;
                    savePrefs();
                    rebuildTable();
                });
            });
        }

        // Taille initiale (une fois)
        function setInitialSizeOnce() {
            if (sizedOnce) return; sizedOnce = true;
            try {
                const table = document.getElementById("spellTable");
                const headW = table.tHead?.getBoundingClientRect().width || 960;
                const margin = 40;
                const w = Math.min(screen.availWidth, Math.ceil(headW + margin));
                const baseHeader = 56 + 60 + 70;
                const rowHeight = 36;
                const rowsWanted = 18;
                const h = Math.min(screen.availHeight, baseHeader + rowHeight * rowsWanted + 80);

                if (window.electronAPI?.resizeChildWindow) {
                    window.electronAPI.resizeChildWindow("SpellDetails", w, h);
                } else {
                    window.resizeTo(w, h);
                }
            } catch { }
        }

        // Persistance préférences
        function loadPrefs() {
            try {
                const p = JSON.parse(localStorage.getItem(PREF_KEY) || "{}");
                if (p.sortKey) sortKey = p.sortKey;
                if (p.sortDir) sortDir = p.sortDir;
                if (p.search != null) search.value = p.search;
                if (p.modeFilter) {
                    modeFilter = p.modeFilter;
                    document.querySelectorAll('.seg-btn').forEach(b => b.classList.toggle('active', b.dataset.mode === modeFilter));
                }
            } catch { }
        }
        function savePrefs() {
            localStorage.setItem(PREF_KEY, JSON.stringify({
                sortKey, sortDir, search: search.value, modeFilter
            }));
        }

        // Raccourci "/" pour focus recherche
        document.addEventListener('keydown', (e) => {
            if (e.key === '/' && document.activeElement !== search) {
                e.preventDefault(); search.focus();
            }
        });
        ['input', 'change', 'keyup'].forEach(ev => search.addEventListener(ev, () => { savePrefs(); rebuildTable(); }));

        window.addEventListener("message", (ev) => {
            if (!ev?.data || ev.data.type !== "spell-data") return;
            DATA = ev.data.payload;
            loadPrefs();
            bindSortingOnce();
            renderHeader();

            const key = `${DATA.user.id}_${DATA.items.length}_${sortKey}_${sortDir}_${modeFilter}_prefs_v1`;
            if (key !== lastRenderKey) { rebuildTable(); lastRenderKey = key; }
            else { updateValuesOnly(); }
        });

        document.addEventListener("keydown", e => { if (e.key === "Escape") window.close(); });
    </script>
</body>
</html>
